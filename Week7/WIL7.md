## 객체 지향 설계 5원칙 SOLID <br>
solid는 한마디로 우리가 만드는 제품, 즉 소프트웨어에 녹여 내야 하는 개념이다. 이를 잘 녹여낸 소프트웨어는 그렇지 않은 소프트웨어에 비해 상대적으로 이해하기 쉽고, 리펙터링과 유지보수가 수월할 뿐 아니라 논리적으로 정연하다. <br>
<br>

> ## SRP, 단일 책임 원칙 <br>
**"어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." - 로버트 C. 마틴** <br>
<br>
**1. 예를 들어 보자.** <br>
**남자**라는 클래스가 있고 남자 클래스에 **의존하는 다양한 클래스**(여자친구, 어머니, 직장상사, 소대장)가 있다. 남자라는 클래스에 다수의 역할과 책임이 몰려있는 상황이다. 어느 날 여자친구와 헤어진 남자 클래스는 기념일을 챙길일과 키스할 대상이 없어져 힘들어한다. 이로 인한 스트레스를 주변에 퍼뜨려 어머니, 직장상사, 소대장까지 피곤하게 될 것이다. 이럴 경우에는 책임을 분리해야 한다. <br>
남자라는 하나의 클래스가 각 역할의 **책임에 따라 네 개의 클래스로 쪼개지면 주변에 영향을 주지않게** 되고 이해하기도 쉬워진다. <br>
<br>
**2.잘못된 경우를 살펴보자.** <br>

<남자는 반드시 군대에 가고, 여자는 절대로 군대를 가지 않는다고 가정했을 때, 사람 클래스에 군번이라는 속성이 있다면 어떻게 될까?>

>> 1 . 속성이 SRP를 지키지 않은 경우

```
class 사람 {
	String 군번;
	```
	}
	
    ```

사람 로미오 = new 사람();
사람 줄리엣 = new 사람();
	
줄리엣. 군번 = "1573042009"; 
```

이럴 경우에 줄리엣이 가진 군번 속성에 값을 할당하거나 읽어 오는 코드를 제제할 수 없다. 따라서 사람 클래스를 남자 클래스와 여자 클래스로 분할하고 남자 클래스에만 군번 속성을 갖게 하면 된다. <br>
하나의 속성이 여러 의미를 갖는 경우도 단일 책임 원칙을 지키지 못하는 경우다. <br>

>> 2-1. 메서드가 단일 책임 원칙을 지키지 않은 경우
```
class 강아지 {
    final static Boolean 수컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;
    
    void 소변보다() {
        if(this.성별 == 수컷) {
            //한쪽 다리를 들고 소변을 본다.
        } else {
            //뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다.
        }
    }
}
```
이 경우에는 강아지가 수컷이냐 암컷이냐에 따라 **소변보다() 메서드**에서 분기 처리가 진행된다. 강아지 클래스의 소변보다() 메서드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임 원칙을위배하고 있는 것이다. 코드를 리펙터링하면 2-2가 된다. <br>
>> 2-2. 단일 책임 원칙을 적용해 개선한 코드
```
abstract class 강아지 {
    abstract void 소변보다()
}
class 수컷강아지 extends 강아지 {
    void 소변보다() {
        //한쪽 다리를 들고 소변을 본다.
    }
}
class 암컷강아지 extends 강아지 {
    void 소변보다() {
        //뒷다리 두 개로 앉은 자세로 소변을 본다. 
    }
}
```
<br>

단일 책임 원칙을 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해진다. 그리고 이러한 단일 책임 원칙의 장점은 시스템이 커질수록 극대화되는데, 시스템이 커지면서 서로 많은 의존성을 갖게되는 상황에서 변경 요청이 오면 딱 1가지만 수정하면 되기 때문이다. <br>
단일 책임 원칙을 적용하여 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 추상화함으로써 애플리케이션의 변화에 손쉽게 대응할 수 있다. <br>
<br>

*** 

<br>

> ## OCP, 개방 폐쇄 원칙 <br>
**"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴** <br>
**= "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."** <br>
<br>

**1. 예를 들어보자.** <br>
한 운전자가 마티즈를 구입했다. 열심히 마티즈에 적응했는데 훗날 소나타가 생겼다. 창문과 기어가 **수동이던 마티즈**에서 **창문과 기어가 자동인 소나타**로 차종을 바꾸니 운전자의 행동에도 변화가 온다. 이전에는 **기어수동조작()메서드** 를 사용했는데 파종을 변경하지 **기어자동조작()메서드**를 사용하게 된다. 현실세계라면 운전자에게 어느 정도 변화가 있어야 하겠지만 객체 지향 세계에서는 **상위 클래스 또는 인터페이스**를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 운전자는 운전습관에 영향을 받지 않게 된다. 이것이 운전자의 입장에서는 주변의 변화에 폐쇄되어 있는 것이다. <br>
<br>
개방 폐쇄 원칙을 따르지 않는다고 해서 객체 지향 프로그램을 구현하는 것이 불가능한 것은 아니지만 이를 무시하고 작성하면 유연성, 재사용성, 유지보수성을 얻을 수 없다. <br>
<br>

OCP가 본질적으로 얘기하는 것은 **추상화**이며, 이는 결국 런타임 의존성과 컴파일타임 의존성에 대한 이야기이다. 여기서 런타임 의존성이란 애플리케이션 실행 시점에서의 객체들의 관계를 의미하고, 컴파일타임 의존성이란 코드에 표현된 클래스들의 관계를 의미한다. <br>
<br>

*** 

<br>

> ## LSP, 리스코프 치환 원칙 <br>
**"서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마인** <br>

객체 지향의 상속은 다음의 조건을 만족해야한다.
- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is albe to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다. 

이 두 개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다. 하지만 위 문장대로 구현되지 않은 코드가 존재할 수 있는데 바로 **상속이 조직도나 계층도 형태로 구축된 경우다. 리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다. <br>

**"하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다."** <br>
<br>

*** 

<br>

> ## ISP, 인터페이스 분리 원칙 <br>
**"클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다." - 로버트 C. 마틴"** <br>
<br>

**1. SRP를 다시 생각해보자.** <br>
단일 책임 원칙에서 제시한 남자 클래스의 해결법은 남자 클래스를 토막내서 하나의 역할만 하는 다수의 클래스로 분할하는 것이었다. 하지만 방법은 이것만 있는 것이 아니다. 남자 클래스를 토막내는 것이 아니라 **다중 인격화*시켜 여자친구를 만날 때는 남자친구 역할만 할 수 있게 인터페이스로 제한하고, 어머니와 있을 때는 아들 인터페이스로 제한하는 등 으로 인터페이스를 분할 하는 것이 ISP의 핵심이다.  <br>
<br>

**2. 인터페이스 최소주의 원칙** <br>
: 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라 <br>
남자 클래스에서 남자친구 인터페이스에서는 효도하기() 메서드를 제공할 필요도 없고 제공해서도 안된다는 것이다. <br>
<br>
인터페이스 분리 원칙을 준수함으로써 모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스(외부에서 접근 가능한 메세지)만을 접근하여 불필요한 간섭을 최소화할 수 있으며, 기존 클라이언트에 영향을 주지 않은 채로 유연하게 객체의 기능을 확장하거나 수정할 수 있다. <br>
<br>

*** 

<br>

> ## DIP, 의존 역전 원칙 <br>
**"고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 모듈 모두 다른 추상화된 것에 의존해야 한다."** <br>
**"추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."** <br>
**"자주 변경되는 구체(concrete)클래스에 의존하지 마라." - 로버트 C. 마틴** <br>
<br>

**1. 예를 들어보자.** <br>
**자동차**와 **스노우타이어**사이에는 의존 관계가 있다. 자동차가 스노우타이어에 의존한다. 그런데 자동차는 한 번 사면 몇 번 타는 반면에 스노우타이어는 계절이 바뀌면 일반 타이어로 교체해야 한다. 이런 경우 스노우타이어를 일반타이어로 교체 할 때 자동차는 그 영향에 노출되어 있음을 알 수 있다. <br>
<br>
**2. 해결** <br>
자동차가 구체적인 타이어들(스노우타이어, 일반타이어)이 아닌 추상화된 타이어 인터페이스에만 의존하게 함으로써 스노우타이어에서 일반타이어로, 또는 다른 구체적인 타이어로 변경돼도 자동차는 이제 그 영향을 받지 않는 형태로 구성된다. <br>
기존에는 스노우타이어가 그 무엇에도 의존하지 않았는 클래스였는데 추상적인 것인 타이어 인터페이스에 의존하게 됐다. 바로 **의존의 방향이 역전된 것이다.** <br>
이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 번 하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다. <br>
<br>
**"자신보다 변하기 쉬운 것에 의존하지 마라."**
